/*
	Heterogeneous Heartbeats: Dummy Hardware Heartbeat Generator
    This is a module that connects to the Sensor Bus and generates random 
    heartbeats. It is used for testing how heartbeat producers in the
    hardware domain can connect to the infrastructure.
 */
				      
#include <stdio.h>
#include <string.h>
#include "ap_int.h"
#include "ap_utils.h"

#define HWHB_LOCATION 0x44A00000 //This is the location of the AXI-Slave which is on the HWHB module
//In order for hardware modules to register heartbeats they need to know the location of the HWHB module on the 
//sensor bus.

#define APPID 10 //This defines the AppID, heartbeats generated by this module will
//be registered and tracked under this ID.

#define HB_LOG_SIZE 1 //This is the amount of data that is sent to the hardware heartbeat registration 
//module to indicate that a heartbeat has been registered.

void dummy_hwhb_generator(volatile int *sensor_bus, unsigned int *debug1){
  
  //ap_bus is the only valid nativeVivado HLSinterface for memory mapped master ports
#pragma HLS INTERFACE ap_bus port=sensor_bus depth=N
  
  //Port a is assigned to an AXI4-master interface
#pragma HLS RESOURCE variable=sensor_bus core=AXI4M

#pragma HLS RESOURCE variable=return core=AXI4LiteS metadata="-bus_bundle BUS_A"

#pragma HLS INTERFACE ap_none register  port=debug1
#pragma HLS RESOURCE core=AXI4LiteS    variable=debug1 metadata="-bus_bundle BUS_A"

  int i;
  int buff[HB_LOG_SIZE];
  int start = 1;
 
  buff[0] = APPID;  
  memcpy((int *)( sensor_bus + (HWHB_LOCATION + 0x14)/sizeof(int)), buff, HB_LOG_SIZE*sizeof(int));
  ap_wait();
  memcpy((int *)( sensor_bus + (HWHB_LOCATION)/sizeof(int)), &start, sizeof(int));  //Kick the HWHB core to get it going


    return;
}

//Below is the memory space of the hwHB module as a reference for how the signals are being written
//above
 // BUS_A
 //  // 0x00 : Control signals
 //   //        bit 0  - ap_start (Read/Write/COH)
 //    //        bit 1  - ap_done (Read/COR)
 //     //        bit 2  - ap_idle (Read)
 //      //        bit 3  - ap_ready (Read)
 //       //        bit 7  - auto_restart (Read/Write)
 //        //        others - reserved
 //         // 0x04 : Global Interrupt Enable Register
 //          //        bit 0  - Global Interrupt Enable (Read/Write)
 //           //        others - reserved
 //            // 0x08 : IP Interrupt Enable Register (Read/Write)
 //             //        bit 0  - Channel 0 (ap_done)
 //              //        bit 1  - Channel 1 (ap_ready)
 //               //        others - reserved
 //                // 0x0c : IP Interrupt Status Register (Read/TOW)
 //                 //        bit 0  - Channel 0 (ap_done)
 //                  //        bit 1  - Channel 1 (ap_ready)
 //                   //        others - reserved
 //                    // 0x10 : reserved
 //                     // 0x14 : Data signal of inAppID
 //                      //        bit 31~0 - inAppID[31:0] (Read/Write)
 //                       // 0x18 : reserved
 //                        // 0x1c : Data signal of app_list_addr
 //                         //        bit 31~0 - app_list_addr[31:0] (Read/Write)
 //                          // 0x20 : reserved
 //                           // 0x24 : Data signal of debug1
 //                            //        bit 31~0 - debug1[31:0] (Read)
 //                          // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)
 //
